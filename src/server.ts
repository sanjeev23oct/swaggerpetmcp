import dotenv from 'dotenv';
import * as path from 'path';
import fs from 'fs';

// Try to load .env from both root and dist (for manual runs)
const envPathRoot = path.resolve(__dirname, '../.env');
const envPathDist = path.resolve(__dirname, '../../.env');
if (fs.existsSync(envPathRoot)) {
  dotenv.config({ path: envPathRoot });
} else if (fs.existsSync(envPathDist)) {
  dotenv.config({ path: envPathDist });
} else {
  dotenv.config();
}

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import axios from 'axios';
import { router as apiRoutes } from './routes';

const app = express();
const PORT = process.env.PORT || 8017;
const BASE_URL = process.env.BASE_URL || 'https://petstore3.swagger.io/api/v3';

// Security middleware
app.use(helmet());
app.use(cors());

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health check
app.get('/health', (req: express.Request, res: express.Response) => {
  res.json({
    status: 'healthy',
    name: 'Pets26',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    baseUrl: BASE_URL
  });
});

// MCP tool endpoints
app.use('/tools', apiRoutes);

// MCP Protocol Types
interface MCPRequest {
  jsonrpc: '2.0';
  id?: string | number;
  method: string;
  params?: any;
}

interface MCPResponse {
  jsonrpc: '2.0';
  id?: string | number;
  result?: any;
  error?: {
    code: number;
    message: string;
    data?: any;
  };
}

// MCP Server Info
const SERVER_INFO = {
  name: 'Pets26',
  version: '1.0.0',
  description: 'Generated MCP server for Pets26',
  author: 'Generated by openapi-to-mcp'
};

// Available tools from OpenAPI spec
const AVAILABLE_TOOLS = [
  {
    "name": "updatePet",
    "description": "Update an existing pet.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "body": {
          "description": "Update an existent pet in the store"
        }
      },
      "required": [
        "body"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "required": [
        "name",
        "photoUrls"
      ],
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "name": {
          "type": "string",
          "example": "doggie"
        },
        "category": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "format": "int64",
              "example": 1
            },
            "name": {
              "type": "string",
              "example": "Dogs"
            }
          },
          "xml": {
            "name": "category"
          }
        },
        "photoUrls": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "string",
            "xml": {
              "name": "photoUrl"
            }
          }
        },
        "tags": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              },
              "name": {
                "type": "string"
              }
            },
            "xml": {
              "name": "tag"
            }
          }
        },
        "status": {
          "type": "string",
          "description": "pet status in the store",
          "enum": [
            "available",
            "pending",
            "sold"
          ]
        }
      },
      "xml": {
        "name": "pet"
      },
      "description": "Successful operation"
    },
    "operationId": "updatePet"
  },
  {
    "name": "addPet",
    "description": "Add a new pet to the store.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "body": {
          "description": "Create a new pet in the store"
        }
      },
      "required": [
        "body"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "required": [
        "name",
        "photoUrls"
      ],
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "name": {
          "type": "string",
          "example": "doggie"
        },
        "category": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "format": "int64",
              "example": 1
            },
            "name": {
              "type": "string",
              "example": "Dogs"
            }
          },
          "xml": {
            "name": "category"
          }
        },
        "photoUrls": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "string",
            "xml": {
              "name": "photoUrl"
            }
          }
        },
        "tags": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              },
              "name": {
                "type": "string"
              }
            },
            "xml": {
              "name": "tag"
            }
          }
        },
        "status": {
          "type": "string",
          "description": "pet status in the store",
          "enum": [
            "available",
            "pending",
            "sold"
          ]
        }
      },
      "xml": {
        "name": "pet"
      },
      "description": "Successful operation"
    },
    "operationId": "addPet"
  },
  {
    "name": "findPetsByStatus",
    "description": "Finds Pets by status.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "object",
          "properties": {
            "status": {
              "type": "string",
              "default": "available",
              "enum": [
                "available",
                "pending",
                "sold"
              ],
              "description": "Status values that need to be considered for filter"
            }
          },
          "description": "Query parameters"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "array",
      "items": {
        "required": [
          "name",
          "photoUrls"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 10
          },
          "name": {
            "type": "string",
            "example": "doggie"
          },
          "category": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64",
                "example": 1
              },
              "name": {
                "type": "string",
                "example": "Dogs"
              }
            },
            "xml": {
              "name": "category"
            }
          },
          "photoUrls": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "type": "string",
              "xml": {
                "name": "photoUrl"
              }
            }
          },
          "tags": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "format": "int64"
                },
                "name": {
                  "type": "string"
                }
              },
              "xml": {
                "name": "tag"
              }
            }
          },
          "status": {
            "type": "string",
            "description": "pet status in the store",
            "enum": [
              "available",
              "pending",
              "sold"
            ]
          }
        },
        "xml": {
          "name": "pet"
        }
      },
      "description": "successful operation"
    },
    "operationId": "findPetsByStatus"
  },
  {
    "name": "findPetsByTags",
    "description": "Finds Pets by tags.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to filter by"
            }
          },
          "description": "Query parameters"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "array",
      "items": {
        "required": [
          "name",
          "photoUrls"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 10
          },
          "name": {
            "type": "string",
            "example": "doggie"
          },
          "category": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64",
                "example": 1
              },
              "name": {
                "type": "string",
                "example": "Dogs"
              }
            },
            "xml": {
              "name": "category"
            }
          },
          "photoUrls": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "type": "string",
              "xml": {
                "name": "photoUrl"
              }
            }
          },
          "tags": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "format": "int64"
                },
                "name": {
                  "type": "string"
                }
              },
              "xml": {
                "name": "tag"
              }
            }
          },
          "status": {
            "type": "string",
            "description": "pet status in the store",
            "enum": [
              "available",
              "pending",
              "sold"
            ]
          }
        },
        "xml": {
          "name": "pet"
        }
      },
      "description": "successful operation"
    },
    "operationId": "findPetsByTags"
  },
  {
    "name": "getPetById",
    "description": "Find pet by ID.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "petId": {
          "type": "integer",
          "format": "int64",
          "description": "ID of pet to return"
        }
      },
      "required": [
        "petId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "required": [
        "name",
        "photoUrls"
      ],
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "name": {
          "type": "string",
          "example": "doggie"
        },
        "category": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "format": "int64",
              "example": 1
            },
            "name": {
              "type": "string",
              "example": "Dogs"
            }
          },
          "xml": {
            "name": "category"
          }
        },
        "photoUrls": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "string",
            "xml": {
              "name": "photoUrl"
            }
          }
        },
        "tags": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              },
              "name": {
                "type": "string"
              }
            },
            "xml": {
              "name": "tag"
            }
          }
        },
        "status": {
          "type": "string",
          "description": "pet status in the store",
          "enum": [
            "available",
            "pending",
            "sold"
          ]
        }
      },
      "xml": {
        "name": "pet"
      },
      "description": "successful operation"
    },
    "operationId": "getPetById"
  },
  {
    "name": "updatePetWithForm",
    "description": "Updates a pet in the store with form data.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "petId": {
          "type": "integer",
          "format": "int64",
          "description": "ID of pet that needs to be updated"
        },
        "query": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of pet that needs to be updated"
            },
            "status": {
              "type": "string",
              "description": "Status of pet that needs to be updated"
            }
          },
          "description": "Query parameters"
        }
      },
      "required": [
        "petId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "required": [
        "name",
        "photoUrls"
      ],
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "name": {
          "type": "string",
          "example": "doggie"
        },
        "category": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "format": "int64",
              "example": 1
            },
            "name": {
              "type": "string",
              "example": "Dogs"
            }
          },
          "xml": {
            "name": "category"
          }
        },
        "photoUrls": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "string",
            "xml": {
              "name": "photoUrl"
            }
          }
        },
        "tags": {
          "type": "array",
          "xml": {
            "wrapped": true
          },
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              },
              "name": {
                "type": "string"
              }
            },
            "xml": {
              "name": "tag"
            }
          }
        },
        "status": {
          "type": "string",
          "description": "pet status in the store",
          "enum": [
            "available",
            "pending",
            "sold"
          ]
        }
      },
      "xml": {
        "name": "pet"
      },
      "description": "successful operation"
    },
    "operationId": "updatePetWithForm"
  },
  {
    "name": "deletePet",
    "description": "Deletes a pet.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "petId": {
          "type": "integer",
          "format": "int64",
          "description": "Pet id to delete"
        },
        "headers": {
          "type": "object",
          "properties": {
            "api_key": {
              "type": "string",
              "description": ""
            }
          },
          "description": "Request headers"
        }
      },
      "required": [
        "petId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "description": "Pet deleted"
    },
    "operationId": "deletePet"
  },
  {
    "name": "uploadFile",
    "description": "Uploads an image.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "petId": {
          "type": "integer",
          "format": "int64",
          "description": "ID of pet to update"
        },
        "query": {
          "type": "object",
          "properties": {
            "additionalMetadata": {
              "type": "string",
              "description": "Additional Metadata"
            }
          },
          "description": "Query parameters"
        },
        "body": {
          "description": "Request body"
        }
      },
      "required": [
        "petId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "type": "string"
        },
        "message": {
          "type": "string"
        }
      },
      "xml": {
        "name": "##default"
      },
      "description": "successful operation"
    },
    "operationId": "uploadFile"
  },
  {
    "name": "getInventory",
    "description": "Returns pet inventories by status.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "description": "No input parameters required"
    },
    "outputSchema": {
      "type": "object",
      "additionalProperties": {
        "type": "integer",
        "format": "int32"
      },
      "description": "successful operation"
    },
    "operationId": "getInventory"
  },
  {
    "name": "placeOrder",
    "description": "Place an order for a pet.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "body": {
          "description": "Request body"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "petId": {
          "type": "integer",
          "format": "int64",
          "example": 198772
        },
        "quantity": {
          "type": "integer",
          "format": "int32",
          "example": 7
        },
        "shipDate": {
          "type": "string",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "Order Status",
          "example": "approved",
          "enum": [
            "placed",
            "approved",
            "delivered"
          ]
        },
        "complete": {
          "type": "boolean"
        }
      },
      "xml": {
        "name": "order"
      },
      "description": "successful operation"
    },
    "operationId": "placeOrder"
  },
  {
    "name": "getOrderById",
    "description": "Find purchase order by ID.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "integer",
          "format": "int64",
          "description": "ID of order that needs to be fetched"
        }
      },
      "required": [
        "orderId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "petId": {
          "type": "integer",
          "format": "int64",
          "example": 198772
        },
        "quantity": {
          "type": "integer",
          "format": "int32",
          "example": 7
        },
        "shipDate": {
          "type": "string",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "Order Status",
          "example": "approved",
          "enum": [
            "placed",
            "approved",
            "delivered"
          ]
        },
        "complete": {
          "type": "boolean"
        }
      },
      "xml": {
        "name": "order"
      },
      "description": "successful operation"
    },
    "operationId": "getOrderById"
  },
  {
    "name": "deleteOrder",
    "description": "Delete purchase order by identifier.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "integer",
          "format": "int64",
          "description": "ID of the order that needs to be deleted"
        }
      },
      "required": [
        "orderId"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "description": "order deleted"
    },
    "operationId": "deleteOrder"
  },
  {
    "name": "createUser",
    "description": "Create user.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "body": {
          "description": "Created user object"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "username": {
          "type": "string",
          "example": "theUser"
        },
        "firstName": {
          "type": "string",
          "example": "John"
        },
        "lastName": {
          "type": "string",
          "example": "James"
        },
        "email": {
          "type": "string",
          "example": "john@email.com"
        },
        "password": {
          "type": "string",
          "example": "12345"
        },
        "phone": {
          "type": "string",
          "example": "12345"
        },
        "userStatus": {
          "type": "integer",
          "description": "User Status",
          "format": "int32",
          "example": 1
        }
      },
      "xml": {
        "name": "user"
      },
      "description": "successful operation"
    },
    "operationId": "createUser"
  },
  {
    "name": "createUsersWithListInput",
    "description": "Creates list of users with given input array.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "body": {
          "description": "Request body"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "username": {
          "type": "string",
          "example": "theUser"
        },
        "firstName": {
          "type": "string",
          "example": "John"
        },
        "lastName": {
          "type": "string",
          "example": "James"
        },
        "email": {
          "type": "string",
          "example": "john@email.com"
        },
        "password": {
          "type": "string",
          "example": "12345"
        },
        "phone": {
          "type": "string",
          "example": "12345"
        },
        "userStatus": {
          "type": "integer",
          "description": "User Status",
          "format": "int32",
          "example": 1
        }
      },
      "xml": {
        "name": "user"
      },
      "description": "Successful operation"
    },
    "operationId": "createUsersWithListInput"
  },
  {
    "name": "loginUser",
    "description": "Logs user into the system.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "The user name for login"
            },
            "password": {
              "type": "string",
              "description": "The password for login in clear text"
            }
          },
          "description": "Query parameters"
        }
      },
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "string",
      "description": "successful operation"
    },
    "operationId": "loginUser"
  },
  {
    "name": "logoutUser",
    "description": "Logs out current logged in user session.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "description": "No input parameters required"
    },
    "outputSchema": {
      "type": "object",
      "description": "successful operation"
    },
    "operationId": "logoutUser"
  },
  {
    "name": "getUserByName",
    "description": "Get user by user name.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "The name that needs to be fetched. Use user1 for testing"
        }
      },
      "required": [
        "username"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64",
          "example": 10
        },
        "username": {
          "type": "string",
          "example": "theUser"
        },
        "firstName": {
          "type": "string",
          "example": "John"
        },
        "lastName": {
          "type": "string",
          "example": "James"
        },
        "email": {
          "type": "string",
          "example": "john@email.com"
        },
        "password": {
          "type": "string",
          "example": "12345"
        },
        "phone": {
          "type": "string",
          "example": "12345"
        },
        "userStatus": {
          "type": "integer",
          "description": "User Status",
          "format": "int32",
          "example": 1
        }
      },
      "xml": {
        "name": "user"
      },
      "description": "successful operation"
    },
    "operationId": "getUserByName"
  },
  {
    "name": "updateUser",
    "description": "Update user resource.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "name that need to be deleted"
        },
        "body": {
          "description": "Update an existent user in the store"
        }
      },
      "required": [
        "username"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "description": "successful operation"
    },
    "operationId": "updateUser"
  },
  {
    "name": "deleteUser",
    "description": "Delete user resource.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "The name that needs to be deleted"
        }
      },
      "required": [
        "username"
      ],
      "additionalProperties": false
    },
    "outputSchema": {
      "type": "object",
      "description": "User deleted"
    },
    "operationId": "deleteUser"
  }
];

// MCP Protocol Handler - supports both stdio and HTTP
app.post('/mcp', async (req: express.Request, res: express.Response) => {
  try {
    const request: MCPRequest = req.body;

    // Validate JSON-RPC 2.0 format
    if (request.jsonrpc !== '2.0') {
      return res.status(400).json({
        jsonrpc: '2.0',
        id: request.id,
        error: {
          code: -32600,
          message: 'Invalid Request - must be JSON-RPC 2.0'
        }
      });
    }

    const response = await handleMCPRequest(request);
    res.json(response);
  } catch (error: any) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    res.status(500).json({
      jsonrpc: '2.0',
      id: req.body?.id,
      error: {
        code: -32603,
        message: 'Internal error',
        data: errorMessage
      }
    });
  }
});

// SSE endpoint for streaming MCP protocol
app.get('/mcp/sse', (req: express.Request, res: express.Response) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Cache-Control'
  });

  // Send initial connection event
  res.write('data: {"jsonrpc":"2.0","method":"connection","params":{"status":"connected"}}\n\n');

  // Handle client disconnect
  req.on('close', () => {
    res.end();
  });
});

// MCP Request Handler
async function handleMCPRequest(request: MCPRequest): Promise<MCPResponse> {
  const { method, params, id } = request;

  try {
    switch (method) {
      case 'initialize':
        return {
          jsonrpc: '2.0',
          id,
          result: {
            protocolVersion: '2024-11-05',
            capabilities: {
              tools: {},
              logging: {},
              prompts: {},
              resources: {}
            },
            serverInfo: SERVER_INFO
          }
        };

      case 'tools/list':
        return {
          jsonrpc: '2.0',
          id,
          result: {
            tools: AVAILABLE_TOOLS
          }
        };

      case 'tools/call':
        const { name: toolName, arguments: toolArgs } = params;

        // Validate tool exists
        const tool = AVAILABLE_TOOLS.find((t: any) => t.name === toolName);
        if (!tool) {
          return {
            jsonrpc: '2.0',
            id,
            error: {
              code: -32602,
              message: `Tool '${toolName}' not found`
            }
          };
        }

        // Call the tool
        const toolResult = await callTool(toolName, toolArgs);

        return {
          jsonrpc: '2.0',
          id,
          result: {
            content: [
              {
                type: 'text',
                text: JSON.stringify(toolResult, null, 2)
              }
            ]
          }
        };

      case 'ping':
        return {
          jsonrpc: '2.0',
          id,
          result: {}
        };

      default:
        return {
          jsonrpc: '2.0',
          id,
          error: {
            code: -32601,
            message: `Method '${method}' not found`
          }
        };
    }
  } catch (error: any) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      jsonrpc: '2.0',
      id,
      error: {
        code: -32603,
        message: 'Internal error',
        data: errorMessage
      }
    };
  }
}

// Tool execution function
async function callTool(toolName: string, args: any): Promise<any> {
  try {
    // In stdio mode, call the tool functions directly
    if (isStdioMode) {
      // Call the tool function directly based on the tool name
      switch (toolName) {
        case 'updatePet':
          return await executeupdatepet(args);
        case 'addPet':
          return await executeaddpet(args);
        case 'findPetsByStatus':
          return await executefindpetsbystatus(args);
        case 'findPetsByTags':
          return await executefindpetsbytags(args);
        case 'getPetById':
          return await executegetpetbyid(args);
        case 'updatePetWithForm':
          return await executeupdatepetwithform(args);
        case 'deletePet':
          return await executedeletepet(args);
        case 'uploadFile':
          return await executeuploadfile(args);
        case 'getInventory':
          return await executegetinventory(args);
        case 'placeOrder':
          return await executeplaceorder(args);
        case 'getOrderById':
          return await executegetorderbyid(args);
        case 'deleteOrder':
          return await executedeleteorder(args);
        case 'createUser':
          return await executecreateuser(args);
        case 'createUsersWithListInput':
          return await executecreateuserswithlistinput(args);
        case 'loginUser':
          return await executeloginuser(args);
        case 'logoutUser':
          return await executelogoutuser(args);
        case 'getUserByName':
          return await executegetuserbyname(args);
        case 'updateUser':
          return await executeupdateuser(args);
        case 'deleteUser':
          return await executedeleteuser(args);
        default:
          throw new Error(`Unknown tool: ${toolName}`);
      }
    } else {
      // HTTP mode - make actual HTTP request
      const response = await fetch(`http://localhost:${PORT}/tools/${toolName}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(args)
      });

      if (!response.ok) {
        throw new Error(`Tool call failed: ${response.status} ${response.statusText}`);
      }

      return await response.json();
    }
  } catch (error: any) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to execute tool '${toolName}': ${errorMessage}`);
  }
}

// MCP Tools endpoint - lists available tools for MCP clients
app.get('/tools', (req: express.Request, res: express.Response) => {
  try {
    // Load tools from types file if available
    let openApiTools: any[] = [];
    try {
      openApiTools = require('./types').openApiTools || [];
    } catch (error) {
      console.log('[MCP] No types file found, returning empty tools list');
    }

    res.json({
      tools: openApiTools,
      count: openApiTools.length,
      server: {
        name: 'Pets26',
        version: '1.0.0',
        baseUrl: BASE_URL
      }
    });
  } catch (error: any) {
    console.error('[MCP] Error loading tools:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    res.status(500).json({
      error: 'Failed to load tools',
      details: errorMessage
    });
  }
});

// Error handling
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Server error:', error);
  res.status(500).json({
    error: 'Internal server error',
    message: error instanceof Error ? error.message : String(error)
  });
});

// 404 handler
app.use('*', (req: express.Request, res: express.Response) => {
  res.status(404).json({
    error: 'Not found',
    message: `Route ${req.originalUrl} not found`
  });
});

// Individual tool execution functions for stdio mode
async function executeupdatepet(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet`;


  // Prepare request configuration
  const config: any = {
    method: 'PUT',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeaddpet(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet`;


  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executefindpetsbystatus(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/findByStatus`;


  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executefindpetsbytags(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/findByTags`;


  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executegetpetbyid(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/{petId}`;
  url = url.replace('{petId}', encodeURIComponent(args.petId));

  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeupdatepetwithform(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/{petId}`;
  url = url.replace('{petId}', encodeURIComponent(args.petId));

  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executedeletepet(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/{petId}`;
  url = url.replace('{petId}', encodeURIComponent(args.petId));

  // Prepare request configuration
  const config: any = {
    method: 'DELETE',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeuploadfile(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/pet/{petId}/uploadImage`;
  url = url.replace('{petId}', encodeURIComponent(args.petId));

  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executegetinventory(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/store/inventory`;


  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeplaceorder(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/store/order`;


  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executegetorderbyid(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/store/order/{orderId}`;
  url = url.replace('{orderId}', encodeURIComponent(args.orderId));

  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executedeleteorder(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/store/order/{orderId}`;
  url = url.replace('{orderId}', encodeURIComponent(args.orderId));

  // Prepare request configuration
  const config: any = {
    method: 'DELETE',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executecreateuser(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user`;


  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executecreateuserswithlistinput(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/createWithList`;


  // Prepare request configuration
  const config: any = {
    method: 'POST',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeloginuser(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/login`;


  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executelogoutuser(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/logout`;


  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executegetuserbyname(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/{username}`;
  url = url.replace('{username}', encodeURIComponent(args.username));

  // Prepare request configuration
  const config: any = {
    method: 'GET',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };



  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executeupdateuser(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/{username}`;
  url = url.replace('{username}', encodeURIComponent(args.username));

  // Prepare request configuration
  const config: any = {
    method: 'PUT',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

async function executedeleteuser(args: any): Promise<any> {
  // Build URL with path parameters
  let url = `${BASE_URL}/user/{username}`;
  url = url.replace('{username}', encodeURIComponent(args.username));

  // Prepare request configuration
  const config: any = {
    method: 'DELETE',
    url,
    timeout: 30000,
    headers: {
      'Accept': 'application/json'
    }
  };


  // Add request body
  if (args.body) {
    config.data = args.body;
    config.headers['Content-Type'] = 'application/json';
  }

  // Add query parameters
  if (args.query) {
    config.params = args.query;
  }

  // Add headers
  if (args.headers) {
    config.headers = { ...config.headers, ...args.headers };
  }

  // Make API request
  const response = await axios(config);
  return { success: true, data: response.data };
}

// Check if running in stdio mode (for MCP clients like Cline)
// Multiple detection methods for better reliability
const isStdioMode = (
  (process.env.NODE_ENV !== 'production' && process.env.RAILWAY_ENVIRONMENT !== 'production') && (
    process.stdin.isTTY === false ||
    process.argv.includes('--stdio') ||
    process.env.MCP_STDIO_MODE === 'true' ||
    !process.stdout.isTTY
  )
);

if (isStdioMode) {
  // STDIO MODE: Handle MCP protocol via stdin/stdout
  console.error(`ðŸ”Œ MCP Server starting in stdio mode for ${AVAILABLE_TOOLS.length} tools`);
  console.error(`ðŸ”§ Detection: stdin.isTTY=${process.stdin.isTTY}, stdout.isTTY=${process.stdout.isTTY}`);

  // Handle stdio for MCP clients (Cline, Cursor, Windsurf, etc.)
  let buffer = '';

  // Set stdin to raw mode for better handling
  if (process.stdin.setRawMode) {
    process.stdin.setRawMode(false);
  }
  process.stdin.setEncoding('utf8');

  process.stdin.on('data', async (chunk) => {
    try {
      buffer += chunk.toString();

      // Process complete JSON messages (handle both \n and \r\n)
      const lines = buffer.split(/\r?\n/);
      buffer = lines.pop() || '';

      for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine) {
          console.error(`ðŸ“¥ Received: ${trimmedLine.substring(0, 100)}...`);

          try {
            const request: MCPRequest = JSON.parse(trimmedLine);
            const response = await handleMCPRequest(request);
            const responseStr = JSON.stringify(response);

            console.error(`ðŸ“¤ Sending: ${responseStr.substring(0, 100)}...`);
            process.stdout.write(responseStr + '\n');

          } catch (parseError) {
            const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
            console.error(`âŒ Parse error: ${errorMessage}`);
            const errorResponse: MCPResponse = {
              jsonrpc: '2.0',
              error: {
                code: -32700,
                message: 'Parse error',
                data: errorMessage
              }
            };
            process.stdout.write(JSON.stringify(errorResponse) + '\n');
          }
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`âŒ Stdin error: ${errorMessage}`);
    }
  });

  process.stdin.on('end', () => {
    process.exit(0);
  });

} else {
  // HTTP MODE: Start HTTP server for web-based clients
  const server = app.listen(PORT, () => {
    console.log(`ðŸš€  MCP Server running on port ${PORT}`);
    console.log(`ðŸ“‹ Health check: http://localhost:${PORT}/health`);
    console.log(`ðŸ”§ MCP endpoint: http://localhost:${PORT}/mcp`);
    console.log(`ðŸ“¡ SSE endpoint: http://localhost:${PORT}/mcp/sse`);
    console.log(`ðŸ› ï¸  Tools endpoint: http://localhost:${PORT}/tools`);
    console.log(`ðŸŒ Base URL: ${BASE_URL}`);
    console.log(``);
    console.log(`ðŸ“– Available tools: ${AVAILABLE_TOOLS.length}`);
    AVAILABLE_TOOLS.forEach((tool: any) => {
      console.log(`   - ${tool.name}: ${tool.description}`);
    });
    console.log(``);
    console.log(`ðŸ”Œ MCP Client Configuration:`);
    console.log(`   stdio: node ${__filename.replace('.ts', '.js')}`);
    console.log(`   http: POST http://localhost:${PORT}/mcp`);
    console.log(`   sse: GET http://localhost:${PORT}/mcp/sse`);
  });

  // Graceful shutdown for HTTP mode
  process.on('SIGINT', () => {
    console.log('\nðŸ›‘ Shutting down MCP server...');
    server.close(() => {
      process.exit(0);
    });
  });

  process.on('SIGTERM', () => {
    console.log('\nðŸ›‘ Shutting down MCP server...');
    server.close(() => {
      process.exit(0);
    });
  });
}

export default app;
